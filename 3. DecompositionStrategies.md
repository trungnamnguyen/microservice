# 1. Software Architecture

![4modeladdone.JPG](assets/4modeladdone.JPG?t=1700575734472)

The purpose of each view is as follows:

- **Logical view**—The software elements that are created by developers. In object-oriented languages, these elements are classes and packages. The relations between them are the relationships between classes and packages, including inheritance, associations, and depends-on.
- **Implementation view**—The output of the build system. This view consists of modules, which represent packaged code, and components, which are executable or deployable units consisting of one or more modules. In Java, a module is a JAR file, and a component is typically a WAR file or an executable JAR file. The relations between them include dependency relationships between modules and composition relationships between components and modules.
- **Process view**—The components at runtime. Each element is a process, and the relations between processes represent interprocess communication.
- **Deployment**—How the processes are mapped to machines. The elements in this view consist of (physical or virtual) machines and the processes. The relations between machines represent networking. This view also describes the relationship between processes and machines.
- **Scenarios**—The description of an architecture is illustrated using a small set of use cases, or scenarios, which become a fifth view. The scenarios describe sequences of interactions between objects and between processes. They are used to identify architectural elements and to illustrate and validate the architecture design. They also serve as a starting point for tests of an architecture prototype. This view is also known as the use case view.

# 2. Architectural styles

#### THE LAYERED ARCHITECTURAL STYLE

A layered architecture organizes software elements into layers. Each layer has a well-defined set of responsibilities. A layered architecture also constraints the dependencies between the layers

The popular three-tier architecture is the layered architecture applied to the logical view. It organizes the application’s classes into the following tiers or layers:

- **Presentation layer**—Contains code that implements the user interface or external APIs
- **Business logic layer**—Contains the business logic
- **Persistence layer**—Implements the logic of interacting with the database

The layered architecture is a great example of an architectural style, but it does have some significant drawbacks:

- **Single presentation layer**—It doesn’t represent the fact that an application is likely to be invoked by more than just a single system.
- **Single persistence layer**—It doesn’t represent the fact that an application is likely to interact with more than just a single database.
- **Defines the business logic layer as depending on the persistence layer**—In theory, this dependency prevents you from testing the business logic without the database.

#### ABOUT THE HEXAGONAL ARCHITECTURE STYLE

The hexagonal architecture style organizes the logical view in a way that places the business logic at the center. Instead of the presentation layer, the application has one or more *inbound adapters* that handle requests from the outside by invoking the business logic. Similarly, instead of a data persistence tier, the application has one or more *outbound adapters* that are invoked by the business logic and invoke external applications. A key characteristic and benefit of this architecture is that the business logic doesn’t depend on the adapters. Instead, they depend upon it.

![hexaarchitech.JPG](assets/hexaarchitech.JPG?t=1700577745726)

The business logic has one or more ports. A port defines a set of operations and is how the business logic interacts with what’s outside of it. In Java, for example, a port is often a Java interface. There are two kinds of ports: inbound and outbound ports

- An inbound port is an API exposed by the business logic, which enables it to be invoked by external applications. An example of an inbound port is a service interface, which defines a service’s public methods.
- An outbound port is how the business logic invokes external systems. An example of an output port is a repository interface, which defines a collection of data access operations.

# 3. The microservice architecture is an architectural style

Monolithic architecture is an architectural style that structures the implementation view as a single component: a single executable or WAR file.

The microservice architecture is also an architectural style. It structures the implementation view as a set of multiple components: executables or WAR files.
The components are services, and the connectors are the communication protocols that enable those services to collaborate. Each service has its own logical view architecture, which is typically a hexagonal architecture.

#### WHAT IS A SERVICE?

A service is a standalone, independently deployable software component that implements some useful functionality
A service has an API that provides its clients access to its functionality. There are two types of operations: commands and queries

![service.JPG](assets/service.JPG?t=1700581056703)

Each service in a microservice architecture has its own architecture and, potentially, technology stack. But a typical service has a hexagonal architecture. Its API is implemented by adapters that interact with the service’s business logic. The operations adapter invokes the business logic, and the events adapter publishes events emitted by the business logic.

The requirement for services to be loosely coupled and to collaborate only via APIs prohibits services from communicating via a database. You must treat a service’s persistent data like the fields of a class and keep them private. Keeping the data private enables a developer to change their service’s database schema without having to spend time coordinating with developers working on other services. Not sharing database tables also improves runtime isolation. It ensures, for example, that one service can’t hold database locks that block another service. Later on, though, you’ll learn that one downside of not sharing databases is that maintaining data consistency and querying across services are more complex.

#### WHAT IS LOOSE COUPLING?

- This enables the implementation of the service to change without impacting its clients
- They are much easier to understand, change, and test.
  Need: Not sharing database tables also improves runtime isolation
  Ex: that one service can’t hold database locks that block another service.

#### THE ROLE OF SHARED LIBRARIES

- Developers often package functionality in a library (module) so that it can be reused by multiple applications without duplicating code.
  => On the surface, it looks like a good way to reduce code duplication in your services. But you need to ensure that you don’t accidentally introduce coupling between your services.
  => You should strive to use libraries for functionality that’s unlikely to change

#### THE SIZE OF A SERVICE IS MOSTLY UNIMPORTANT

- One problem with the term microservice is that the first thing you hear is micro.
  This suggests that a service should be very small. This is also true of other size-based terms such as miniservice or nanoservice. In reality, size isn’t a useful metric.

# 4. Defining an application’s microservice architecture

**Three-step process**

![threeprocess.JPG](assets/threeprocess.JPG?t=1701225521776)

## 4.1. Identifying the system operations

![identifyoperation.JPG](assets/identifyoperation.JPG?t=1701226168736)

### 4.1.1. CREATING A HIGH-LEVEL DOMAIN MODEL

- Domain model is much simpler than what will ultimately be implemented
- High-level domain model is useful at this stage because it defines the vocabulary for describing the behavior of the system operations
- A domain model is created using standard techniques such as analyzing the nouns in the stories and scenarios and talking to the domain experts

**In Ecommerce:**

**Place Order Story**

```
Given a consumer
And a restaurant
And a delivery address/time that can be served by that restaurant
And an order total that meets the restaurant's order minimum
When the consumer places an order for the restaurant
Then consumer's credit card is authorized
And an order is created in the PENDING_ACCEPTANCE state
And the order is associated with the consumer
And the order is associated with the restaurant
```

=> The nouns in this user scenario hint at the existence of various classes,
including <mark>Consumer, Order, Restaurant, and CreditCard.<mark>

**Accept Order Story**
```
Given an order that is in the PENDING_ACCEPTANCE state
and a courier that is available to deliver the order
When a restaurant accepts an order with a promise to prepare by a particular
time
Then the state of the order is changed to ACCEPTED
And the order's promiseByTime is updated to the promised time
And the courier is assigned to deliver the order
```

=> This scenario suggests the existence of <mark>Courier and Delivery<mark> classes.

### 4.1.2. DEFINING SYSTEM OPERATIONS
There are two types of system operations:
- **Commands**—System operations that create, update, and delete data
- **Queries**—System operations that read (query) data

![table1.JPG](assets/table1.JPG?t=1701226168736)

A command has a specification that defines its parameters, return value, and behavior in terms of the domain model classes. 
The behavior specification consists of preconditions that must be true when the operation is invoked, and post-conditions that are true after the operation is invoked

Here, for example, is the specification of the createOrder() system operation:

![table2.JPG](assets/table2.JPG?t=1701226168736)

Once the system operations have been defined, the next step is to identify the application’s services

### 4.1.3. Defining services by applying the Decompose by business capability pattern

One strategy for creating a microservice architecture is to decompose by business capability. A concept from business architecture modeling, a business capability is something that a business does in order to generate value. The set of capabilities for a given business depends on the kind of business.

Ex:  
- The capabilities of an insurance company typically include Underwriting, Claims management, Billing, Compliance, and so on. 
- The capabilities of an online store include Order management, Inventory management, Shipping, and so on.

#### a. IDENTIFYING BUSINESS CAPABILITIES

A business capability is often focused on a particular business object. For example, the Claim business object is the focus of the Claim management capability. A capability can often be decomposed into sub-capabilities. For example, the Claim management capability has several sub-capabilities, including Claim information management, Claim review, and Claim payment management.

The business capabilities for FTGO include the following: 

**Supplier management**
- **Courier management**—Managing courier information
- **Restaurant information management**—Managing restaurant menus and other information, including location and open hours
**Consumer management**—Managing information about consumers
**Order taking and fulfillment**
- **Order management**—Enabling consumers to create and manage orders
- **Restaurant order management**—Managing the preparation of orders at a restaurant
- Logistics
- **Courier availability management**—Managing the real-time availability of couriers to delivery orders
- **Delivery management**—Delivering orders to consumers
**Accounting**
- **Consumer accounting**—Managing billing of consumers
- **Restaurant accounting**—Managing payments to restaurants
- **Courier accounting**—Managing payments to couriers
...

#### b. FROM BUSINESS CAPABILITIES TO SERVICES