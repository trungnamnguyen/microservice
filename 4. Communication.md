There are lots of different IPC technologies to choose from. Services can use synchronous request/response-based communication mechanisms, such as HTTP-based REST or gRPC. Alternatively, they can use asynchronous, message-based communication mechanisms such as AMQP or STOMP. There are also a variety of different messages formats. Services can use human-readable, text-based formats such as JSON or XML. Alternatively, they could use a more efficient binary format such as Avro or Protocol Buffers.
# 1. Overview of interprocess communication in a microservice architecture 
# 1.1. Interaction styles
#### They can be categorized in two dimensions
The first dimension is whether the interaction is one-to-one or one-to-many:
- One-to-one—Each client request is processed by exactly one service.
- One-to-many—Each request is processed by multiple services.

The second dimension is whether the interaction is synchronous or asynchronous:

- Synchronous—The client expects a timely response from the service and might even block while it waits.
- Asynchronous—The client doesn’t block, and the response, if any, isn’t necessarily sent immediately.

# 1.2. Defining APIs in a microservice architecture
- APIs or interfaces are central to software development. An application is comprised of modules. Each module has an interface that defines the set of operations that module’s clients can invoke
- The challenge is that a service API isn’t defined using a simple programming language construct. By definition, a service and its clients aren’t compiled together. If a new version of a service is deployed with an incompatible API, there’s no compilation error. Instead, there will be runtime failures.
- Regardless of which IPC mechanism you choose, it’s important to precisely define a service’s API using some kind of interface definition language (IDL)
# 1.3. Evolving APIs
In a microservices-based application, changing a service’s API is a lot more difficult. A service’s clients are other services, which are often developed by other teams. The clients may even be other applications outside of the organization. You usually can’t force all clients to upgrade in lockstep with the service

Strategy:
- USE SEMANTIC VERSIONING: The Semantic Versioning specification (http://semver.org)

The Semantic Versioning specification (Semvers) requires a version number to consist of three parts: MAJOR.MINOR.PATCH. You must increment each part of a version number as follows:

MAJOR—When you make an incompatible change to the API
MINOR—When you make backward-compatible enhancements to the API
PATCH—When you make a backward-compatible bug fix

- MAKING MINOR, BACKWARD-COMPATIBLE CHANGES

Ideally, you should strive to only make backward-compatible changes. Backward-compatible changes are additive changes to an API:

Adding optional attributes to request
Adding attributes to a response
Adding new operations
# 1.4. Message formats

There are two main categories of message formats: text and binary

TEXT-BASED MESSAGE FORMATS:
- The first category is text-based formats such as JSON and XML.An advantage of these formats is that not only are they human readable, they’re self describing. A downside of using a text-based messages format is that the messages tend to be verbose, especially XML. Every message has the overhead of containing the names of the attributes in addition to their values. Another drawback is the overhead of parsing text, especially when messages are large. Consequently, if efficiency and performance are important, you may want to consider using a binary format.
BINARY MESSAGE FORMATS: Popular formats include Protocol Buffers  and Avro. Both formats provide a typed IDL for defining the structure of your messages. A compiler then generates the code that serializes and deserializes the messages
# 2. Communicating using the synchronous Remote procedure invocation pattern
# 2.1. Using REST
THE REST MATURITY MODEL 
Following levels:

- Level 0—Clients of a level 0 service invoke the service by making HTTP POST requests to its sole URL endpoint. Each request specifies the action to perform, the target of the action (for example, the business object), and any parameters.
- Level 1—A level 1 service supports the idea of resources. To perform an action on a resource, a client makes a POST request that specifies the action to perform and any parameters.
- Level 2—A level 2 service uses HTTP verbs to perform actions: GET to retrieve, POST to create, and PUT to update. The request query parameters and body, if any, specify the actions’ parameters. This enables services to use web infrastructure such as caching for GET requests.
- Level 3—The design of a level 3 service is based on the terribly named HATEOAS (Hypertext As The Engine Of Application State) principle. The basic idea is that the representation of a resource returned by a GET request contains links for performing actions on that resource. For example, a client can cancel an order using a link in the representation returned by the GET request that retrieved the order. The benefits of HATEOAS include no longer having to hard-wire URLs into client code.

BENEFITS AND DRAWBACKS OF REST

There are numerous benefits to using REST:

- It’s simple and familiar.
- You can test an HTTP API from within a browser using, for example, the Postman plugin, or from the command line using curl (assuming JSON or some other text format is used).
- It directly supports request/response style communication.
- HTTP is, of course, firewall friendly.
- It doesn’t require an intermediate broker, which simplifies the system’s architecture.

There are some drawbacks to using REST:

- It only supports the request/response style of communication.
- Reduced availability. Because the client and service communicate directly without an intermediary to buffer messages, they must both be running for the duration of the exchange.
- Clients must know the locations (URLs) of the service instances(s). As described in section 3.2.4, this is a nontrivial problem in a modern application. Clients must use what is known as a service discovery mechanism to locate service instances.
- Fetching multiple resources in a single request is challenging.
- It’s sometimes difficult to map multiple update operations to HTTP verbs.

# 2.1. Using gRPC

gRPC has several benefits:

- It’s straightforward to design an API that has a rich set of update operations.
- It has an efficient, compact IPC mechanism, especially when exchanging large messages.
- Bidirectional streaming enables both RPI and messaging styles of communication.
- It enables interoperability between clients and services written in a wide range of languages.

gRPC also has several drawbacks:

It takes more work for JavaScript clients to consume gRPC-based API than REST/JSON-based APIs.
Older firewalls might not support HTTP/2.

# 3. Communicating using the Asynchronous messaging pattern

# 3.1. Overview of messaging

A sender (an application or service) writes a message to a channel, and a receiver (an application or service) reads messages from a channel.

There are several different kinds of messages:

- Document—A generic message that contains only data. The receiver decides how to interpret it. The reply to a command is an example of a document message.
- Command—A message that’s the equivalent of an RPC request. It specifies the operation to invoke and its parameters.
- Event—A message indicating that something notable has occurred in the sender. An event is often a domain event, which represents a state change of a domain object such as an Order, or a Customer.

There are two kinds of channels:

- A point-to-point channel delivers a message to exactly one of the consumers that is reading from the channel. Services use point-to-point channels for the one-to-one interaction styles described earlier. For example, a command message is often sent over a point-to-point channel.
- A publish-subscribe channel delivers each message to all of the attached consumers. Services use publish-subscribe channels for the one-to-many interaction styles described earlier. For example, an event message is usually sent over a publish-subscribe channel.