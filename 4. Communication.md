There are lots of different IPC technologies to choose from. Services can use synchronous request/response-based communication mechanisms, such as HTTP-based REST or gRPC. Alternatively, they can use asynchronous, message-based communication mechanisms such as AMQP or STOMP. There are also a variety of different messages formats. Services can use human-readable, text-based formats such as JSON or XML. Alternatively, they could use a more efficient binary format such as Avro or Protocol Buffers.
# 1. Overview of interprocess communication in a microservice architecture 
# 1.1. Interaction styles

#### They can be categorized in two dimensions
The first dimension is whether the interaction is one-to-one or one-to-many:
- One-to-one—Each client request is processed by exactly one service.
- One-to-many—Each request is processed by multiple services.

The second dimension is whether the interaction is synchronous or asynchronous:

- Synchronous—The client expects a timely response from the service and might even block while it waits.
- Asynchronous—The client doesn’t block, and the response, if any, isn’t necessarily sent immediately.

# 1.2. Defining APIs in a microservice architecture
# 1.3. Evolving APIs
# 1.4. Message formats

There are two main categories of message formats: text and binary

TEXT-BASED MESSAGE FORMATS:
- The first category is text-based formats such as JSON and XML
# 2. Communicating using the synchronous Remote procedure invocation pattern
# 2.1. Using REST

THE REST MATURITY MODEL
Following levels:

- Level 0—Clients of a level 0 service invoke the service by making HTTP POST requests to its sole URL endpoint. Each request specifies the action to perform, the target of the action (for example, the business object), and any parameters.
- Level 1—A level 1 service supports the idea of resources. To perform an action on a resource, a client makes a POST request that specifies the action to perform and any parameters.
- Level 2—A level 2 service uses HTTP verbs to perform actions: GET to retrieve, POST to create, and PUT to update. The request query parameters and body, if any, specify the actions’ parameters. This enables services to use web infrastructure such as caching for GET requests.
- Level 3—The design of a level 3 service is based on the terribly named HATEOAS (Hypertext As The Engine Of Application State) principle. The basic idea is that the representation of a resource returned by a GET request contains links for performing actions on that resource. For example, a client can cancel an order using a link in the representation returned by the GET request that retrieved the order. The benefits of HATEOAS include no longer having to hard-wire URLs into client code