ACID (Atomicity, Consistency, Isolation, Durability) transactions greatly simplify the job of the developer by providing the illusion that each transaction has exclusive access to the data

In a microservice architecture, transactions that are within a single service can still use ACID transactions. The challenge, however, lies in implementing transactions for operations that update data owned by multiple services.

Instead of an ACID transactions, an operation that spans services must use what’s known as a saga, a message-driven sequence of local transactions, to maintain data consistency

# 1. Using the Saga pattern to maintain data consistency

Sagas are mechanisms to maintain data consistency in a microservice architecture without having to use distributed transactions.

A saga is a sequence of local transactions. Each local transaction updates data within a single service using the familiar ACID transaction frameworks.

Sagas differ from ACID transactions in a couple of important ways. They lack the isolation property of ACID transactions. Also, because each local transaction commits its changes, a saga must be rolled back using compensating transactions.

**AN EXAMPLE SAGA: THE CREATE ORDER SAGA**

![sagaexample.JPG](assets/sagaexample.JPG?t=1700581056703)

This saga consists of the following local transactions:

- Order Service—Create an Order in an APPROVAL_PENDING state.
- Consumer Service—Verify that the consumer can place an order.
- Kitchen Service—Validate order details and create a Ticket in the CREATE_PENDING.
- Accounting Service—Authorize consumer’s credit card.
- Kitchen Service—Change the state of the Ticket to AWAITING_ACCEPTANCE.
- Order Service—Change the state of the Order to APPROVED.

**SAGAS USE COMPENSATING TRANSACTIONS TO ROLL BACK CHANGES**

![sagaundo.JPG](assets/sagaundo.JPG?t=1700581056703)


![sagacompensating.JPG](assets/sagacompensating.JPG?t=1700581056703)

In this scenario, the saga executes the following local transactions:

- Order Service—Create an Order in an APPROVAL_PENDING state.
- Consumer Service—Verify that the consumer can place an order.
- Kitchen Service—Validate order details and create a Ticket in the CREATE_PENDING state.
- Accounting Service—Authorize consumer’s credit card, which fails.
- Kitchen Service—Change the state of the Ticket to CREATE_REJECTED.
- Order Service—Change the state of the Order to REJECTED.

# 2. Coordinating sagas

There are a couple of different ways to structure a saga’s coordination logic:

- **Choreography**—Distribute the decision making and sequencing among the saga participants. They primarily communicate by exchanging events.
- **Orchestration**—Centralize a saga’s coordination logic in a saga orchestrator class. A saga orchestrator sends command messages to saga participants telling them which operations to perform.

## 2.1. Choreography-based sagas
## 2.2. Orchestration-based sagas